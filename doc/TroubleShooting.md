### #1    重复调用drawStringF出现杂点
   -#2015年02月10日12:57:09    
  ->初步判断是printf函数的问题   
  ->确认是任务切换寄存器恢复的问题  
  ->r0和r1寄存器恢复次序颠倒导致未知错误   
  -#2015年02月11日21:43:18  已解决
  
### #2   printf相关的函数有问题,尤其是%x 和 %f输出的时候
   -#2015年02月20日17:51:32

### #3   GPIO_SET_GPFSEL 函数有问题
   -#2015年02月20日17:52:04
   -#2015年02月24日14:10:11  已解决
   
### #4	send MSG 有可能使系统进入死循环   
   -#2015年02月20日17:29:47
   ->初步判断是printf函数的问题 task_send_msg 函数的问题
   ->确认是任MSG_dispose函数的问题  将调试信息打印到屏幕,发现是任务调度函数中处理消息的函数有问题,上一个任务的消息没有清除,当做当前任务的消息,而改变了当前任务的状态,使任务不能正常调度,当所有的任务都不能被调度的时候,调度函数进入死循环,此时系统中断也处于关闭状态
    -#2015年02月20日18:03:44  已解决
    
### #5	图层复制的时候出现莫名其妙的错误,颜色不正确
   -#2015-02-27 17:06:03
   ->C语言中结构体不能直接赋值,c++中可以,必须逐一赋值
   ->2015年02月27日17:12:56    已解决
     
### #6	图层设置有问题
    -#2015年03月05日19:07:01
    ->#2015年03月09日22:08:03  已解决   
    
### #7	UART中断无法正常返回
    -#2015年03月09日22:08:54  
    ->用控制变量法确定是UART_irq_handler函数的问题。具体是这个函数什么问题还不知道 
    -> 将函数换成sleep(500), 要是这次UART数据还没有处理完在发生中断就会产生这种情况，所以不是UART_irq_handler函数本身的问题
    -> 问题原因是自己写的中断返回代码中，先恢复cpsr的值，在pc恢复之前开启了中断。这时候在发生一次中断，r0， r1， pc的值会出现问题
    ->解决办法，先判断是UART中断还是timer中断。然后根据两种情况写不同的返回代码。
    -># 2015年03月10日17:55:06  已解决   
    
    
    